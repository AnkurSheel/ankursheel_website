---
title: "Unity CI/CD Demystified: Part 3: Build with Linux"
excerpt: "In Part 3 of our Unity CI/CD series, we delve into creating a reusable workflow to build Unity projects for different platforms."
category: "programming"
tags:
- "unity"
- "tutorial"
- "devops"

---

Welcome back to our Unity CI/CD journey.

In Part 1, we nailed down the [One-Time Setup for Unity CD](./unity-cicd-one-time-setup).

In Part 2, we set the [Trigger Events and Automation Testing for Unity CD](./unity-cicd-trigger-events-tests)

It's time for Part 3, where we will create a reusable workflow to build the Unity project for various platforms. The jobs in this workflow will run on a Linux VM.  

Why Linux? Its the cheapest box. As we will see in later posts, different platforms need different VM for deployment. I am looking at you iOS. 

Let's kick things off with creating a new workflow definition `.github/workflows/buildWithLinux.yml`:

## Defining the Workflow

```yaml
name: Build with Linux  
on:  
  workflow_call:   
    inputs:   
      platform:  
        required: true  
        type: string  
      secrets:  
        UNITY_EMAIL:  
          required: true  
        UNITY_PASSWORD:  
          required: true  
        UNITY_LICENSE:  
          required: true  
    outputs:  
      buildVersion:  
        value: ${{ jobs.buildWithLinux.outputs.buildVersion }} 
```

- **on**: In this section, we specify the events that trigger our CI/CD workflow.
    - **workflow_call**: This lets the runner know that this workflow is reusable and can be called from other workflows.
    - **inputs**: These are the values passed in from the caller workflow and referenced in the job.
        - **platform**: Specifies the platform for which the Unity project should be built. This is crucial because Unity optimizes the build for the target platform and creates the appropriate files.
    - **secrets**: These are the secrets passed in from the caller workflow and used in the job.
    - **outputs**: Data that we want to pass back to the caller workflow.
        - **buildVersion**: The version generated by the job.

## Inside the Linux Build Job

```yaml
jobs:  
  
  buildWithLinux:  
    name: Build in Linux for ${{ inputs.platform }}  
    runs-on: ubuntu-latest  
    outputs:  
      buildVersion: ${{ steps.build.outputs.buildVersion }}  
      steps:  
      - name: Checkout Repository  
        uses: actions/checkout@v3  
        with:  
          fetch-depth: 0  
          lfs: true  
  
      - name: Cache Library  
        uses: actions/cache@v3  
        with:  
          path: Library  
          key: Library-build-${{ inputs.platform }}  
          restore-keys: |  
            Library-build- ${{ inputs.platform }}
            Library-    
      - name: Build Unity Project  
        id: build  
        uses: game-ci/unity-builder@v3  
        env:  
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}  
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}  
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}  
        with:  
          targetPlatform: ${{ inputs.platform }}  
  
      - name: Upload Build  
        uses: actions/upload-artifact@v3  
        with:  
          name: build-${{ inputs.platform }}  
          path: build/${{ inputs.platform }}
```

Here's a breakdown of what's happening in this job:

- **outputs**: Data we want to use in the caller workflow.
    - **buildVersion**: The version generated by the Builder in the `build` step below.
- **steps:** This section contains a series of steps to be executed for this job.
    - **Checkout Repository:** This step checks out our code repository. We're diving deep into the Git history with a fetch depth of 0 and grabbing those Git Large File Storage (LFS) files with the `lfs: true` flag.
    - **Cache Library:** This step caches the "Library" directory, making subsequent runs faster. We specify the directory path, a key for the cache, and the keys to look for when restoring the cache.  We ensure that the `key` is unique to each platform, allowing the job to retrieve the correct cache.
    - **Build Unity Project**: In this step, we build the Unity project and set the variables that have been passed in from the caller workflow
    - **Upload Build**: Upload the built Unity project as an artifact so it can be downloaded in later jobs.

## Conclusion

With this workflow in place, we're one step closer to mastering CI/CD for Unity. Stay tuned for Part 4, where we'll cover using this workflow to build and deploy the WebGL build on GitHub pages.

Happy building!

## References

- [Creating a reusable workflow](https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow)
- [Defining Outputs for a job](https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs)
- [GameCI builder Configuration](https://game.ci/docs/github/builder#configuration-options)
- [GameCI builder Output](https://game.ci/docs/github/builder#outputs)
